"""
Debug Event Capture Hooks and Interfaces.

This module provides the capture layer for debug events. It defines
protocols for capture implementations and provides a default capture
class that can be used out of the box.
"""

from __future__ import annotations

from datetime import datetime, UTC
from typing import Any, Dict, Optional, Protocol, runtime_checkable

from .events import (
    DebugEvent,
    DebugEventType,
    DebugEventSeverity,
    node_start_event,
    node_end_event,
    node_error_event,
    node_bypass_event,
    graph_start_event,
    graph_end_event,
)


@runtime_checkable
class DebugCaptureHook(Protocol):
    """
    Protocol for debug event capture implementations.
    
    Implementations of this protocol are responsible for creating
    DebugEvent instances when various node/graph lifecycle events occur.
    """
    
    @property
    def enabled(self) -> bool:
        """Whether capture is currently enabled."""
        ...
    
    def on_node_start(
        self,
        node_id: str,
        node_type: str,
        node_class: str,
        inputs: Dict[str, Any],
    ) -> DebugEvent:
        """
        Capture a node start event.
        
        Args:
            node_id: Unique identifier for the node
            node_type: Type of the node (e.g., 'LLM', 'TEXT')
            node_class: Class name of the node
            inputs: Input values received by the node
            
        Returns:
            DebugEvent for the node start
        """
        ...
    
    def on_node_end(
        self,
        node_id: str,
        node_type: str,
        node_class: str,
        outputs: Dict[str, Any],
        internal_state: Dict[str, Any],
        duration_ms: float,
        start_time: datetime,
    ) -> DebugEvent:
        """
        Capture a node end event.
        
        Args:
            node_id: Unique identifier for the node
            node_type: Type of the node
            node_class: Class name of the node
            outputs: Output values generated by the node
            internal_state: Internal node variables
            duration_ms: Execution duration in milliseconds
            start_time: When node execution started
            
        Returns:
            DebugEvent for the node end
        """
        ...
    
    def on_node_error(
        self,
        node_id: str,
        node_type: str,
        node_class: str,
        error: Exception,
        context: Dict[str, Any],
    ) -> DebugEvent:
        """
        Capture a node error event.
        
        Args:
            node_id: Unique identifier for the node
            node_type: Type of the node
            node_class: Class name of the node
            error: The exception that occurred
            context: Additional context information
            
        Returns:
            DebugEvent for the node error
        """
        ...
    
    def on_node_bypass(
        self,
        node_id: str,
        node_type: str,
        node_class: str,
        reason: str,
        bypass_source: str,
        inputs_at_bypass: Dict[str, Any],
    ) -> DebugEvent:
        """
        Capture a node bypass event.
        
        Args:
            node_id: Unique identifier for the node
            node_type: Type of the node
            node_class: Class name of the node
            reason: Why the node was bypassed
            bypass_source: Which node triggered the bypass
            inputs_at_bypass: Input values at time of bypass
            
        Returns:
            DebugEvent for the node bypass
        """
        ...


class DefaultDebugCapture:
    """
    Default implementation of debug event capture.
    
    This class provides a complete implementation of the capture protocol
    with safe data copying and automatic sequence numbering.
    
    Example:
        capture = DefaultDebugCapture(execution_id="abc123")
        event = capture.on_node_start(
            node_id="node-1",
            node_type="LLM",
            node_class="NodeLLM",
            inputs={"prompt": "Hello"}
        )
    """
    
    def __init__(self, execution_id: str, enabled: bool = True):
        """
        Initialize the capture.
        
        Args:
            execution_id: Unique identifier for this execution
            enabled: Whether capture is enabled
        """
        self._execution_id = execution_id
        self._enabled = enabled
        self._sequence = 0
        self._graph_start_time: Optional[datetime] = None
    
    @property
    def enabled(self) -> bool:
        """Whether capture is currently enabled."""
        return self._enabled
    
    @enabled.setter
    def enabled(self, value: bool) -> None:
        """Set whether capture is enabled."""
        self._enabled = value
    
    @property
    def execution_id(self) -> str:
        """Get the execution ID."""
        return self._execution_id
    
    def _next_sequence(self) -> int:
        """Get the next sequence number."""
        self._sequence += 1
        return self._sequence
    
    def _safe_copy(self, data: Any) -> Any:
        """
        Create a serialization-safe copy of data.
        
        Handles nested dictionaries, lists, and converts complex
        objects to string representations.
        
        Args:
            data: Data to copy
            
        Returns:
            Serialization-safe copy
        """
        if data is None or isinstance(data, (bool, int, float, str)):
            return data
        
        if isinstance(data, dict):
            # Special handling for node output format
            if 'node' in data and 'content' in data:
                return {
                    'node': data['node'],
                    'content': self._safe_copy(data['content'])
                }
            return {k: self._safe_copy(v) for k, v in data.items()}
        
        if isinstance(data, (list, tuple)):
            return [self._safe_copy(item) for item in data]
        
        # For complex objects, get a string representation
        try:
            if hasattr(data, '__dict__'):
                return f"<{data.__class__.__name__}>"
            return str(data)
        except Exception:
            return f"<{type(data).__name__}>"
    
    def on_node_start(
        self,
        node_id: str,
        node_type: str,
        node_class: str,
        inputs: Dict[str, Any],
    ) -> DebugEvent:
        """Capture a node start event."""
        return node_start_event(
            execution_id=self._execution_id,
            node_id=node_id,
            node_type=node_type,
            node_class=node_class,
            inputs=self._safe_copy(inputs),
            sequence=self._next_sequence(),
        )
    
    def on_node_end(
        self,
        node_id: str,
        node_type: str,
        node_class: str,
        outputs: Dict[str, Any],
        internal_state: Dict[str, Any],
        duration_ms: float,
        start_time: datetime,
    ) -> DebugEvent:
        """Capture a node end event."""
        return node_end_event(
            execution_id=self._execution_id,
            node_id=node_id,
            node_type=node_type,
            node_class=node_class,
            outputs=self._safe_copy(outputs),
            internal_state=self._safe_copy(internal_state),
            duration_ms=duration_ms,
            start_time=start_time,
            sequence=self._next_sequence(),
        )
    
    def on_node_error(
        self,
        node_id: str,
        node_type: str,
        node_class: str,
        error: Exception,
        context: Dict[str, Any],
    ) -> DebugEvent:
        """Capture a node error event."""
        return node_error_event(
            execution_id=self._execution_id,
            node_id=node_id,
            node_type=node_type,
            node_class=node_class,
            error=error,
            context=self._safe_copy(context),
            sequence=self._next_sequence(),
        )
    
    def on_node_bypass(
        self,
        node_id: str,
        node_type: str,
        node_class: str,
        reason: str,
        bypass_source: str,
        inputs_at_bypass: Dict[str, Any],
    ) -> DebugEvent:
        """Capture a node bypass event."""
        return node_bypass_event(
            execution_id=self._execution_id,
            node_id=node_id,
            node_type=node_type,
            node_class=node_class,
            reason=reason,
            bypass_source=bypass_source,
            inputs_at_bypass=self._safe_copy(inputs_at_bypass),
            sequence=self._next_sequence(),
        )
    
    def on_graph_start(self, graph_type: str, total_nodes: int = 0) -> DebugEvent:
        """
        Capture a graph start event.
        
        Args:
            graph_type: Type of graph being executed
            total_nodes: Total number of nodes in the graph
            
        Returns:
            DebugEvent for the graph start
        """
        self._graph_start_time = datetime.now(UTC)
        return graph_start_event(
            execution_id=self._execution_id,
            graph_type=graph_type,
            total_nodes=total_nodes,
            sequence=self._next_sequence(),
        )
    
    def on_graph_end(
        self,
        total_nodes: int,
        executed_nodes: int,
        bypassed_nodes: int,
        failed_nodes: int,
        start_time: Optional[datetime] = None,
    ) -> DebugEvent:
        """
        Capture a graph end event.
        
        Args:
            total_nodes: Total number of nodes in the graph
            executed_nodes: Number of nodes that executed
            bypassed_nodes: Number of nodes that were bypassed
            failed_nodes: Number of nodes that failed
            start_time: When graph execution started (uses stored time if None)
            
        Returns:
            DebugEvent for the graph end
        """
        actual_start_time = start_time or self._graph_start_time or datetime.now(UTC)
        return graph_end_event(
            execution_id=self._execution_id,
            total_nodes=total_nodes,
            executed_nodes=executed_nodes,
            bypassed_nodes=bypassed_nodes,
            failed_nodes=failed_nodes,
            start_time=actual_start_time,
            sequence=self._next_sequence(),
        )
    
    def on_input_received(
        self,
        node_id: str,
        node_type: str,
        node_class: str,
        handle: str,
        source_node: str,
        data: Any,
    ) -> DebugEvent:
        """
        Capture an input received event.
        
        Args:
            node_id: Node receiving the input
            node_type: Type of the node
            node_class: Class name of the node
            handle: Input handle name
            source_node: Node that sent the data
            data: The data received
            
        Returns:
            DebugEvent for the input received
        """
        return DebugEvent(
            event_type=DebugEventType.INPUT_RECEIVED,
            execution_id=self._execution_id,
            sequence_number=self._next_sequence(),
            node_id=node_id,
            node_type=node_type,
            node_class=node_class,
            payload={
                "handle": handle,
                "source_node": source_node,
                "data_preview": self._safe_copy(data)[:100] if isinstance(data, str) else self._safe_copy(data),
            },
        )
    
    def on_output_produced(
        self,
        node_id: str,
        node_type: str,
        node_class: str,
        handle: str,
        data: Any,
    ) -> DebugEvent:
        """
        Capture an output produced event.
        
        Args:
            node_id: Node producing the output
            node_type: Type of the node
            node_class: Class name of the node
            handle: Output handle name
            data: The data produced
            
        Returns:
            DebugEvent for the output produced
        """
        return DebugEvent(
            event_type=DebugEventType.OUTPUT_PRODUCED,
            execution_id=self._execution_id,
            sequence_number=self._next_sequence(),
            node_id=node_id,
            node_type=node_type,
            node_class=node_class,
            payload={
                "handle": handle,
                "data_preview": self._safe_copy(data)[:100] if isinstance(data, str) else self._safe_copy(data),
            },
        )
    
    def on_edge_traversed(
        self,
        source_node: str,
        target_node: str,
        source_handle: str,
        target_handle: str,
        data: Any,
    ) -> DebugEvent:
        """
        Capture an edge traversal event.
        
        Args:
            source_node: Source node ID
            target_node: Target node ID
            source_handle: Source output handle
            target_handle: Target input handle
            data: Data flowing through the edge
            
        Returns:
            DebugEvent for the edge traversal
        """
        return DebugEvent(
            event_type=DebugEventType.EDGE_TRAVERSED,
            severity=DebugEventSeverity.TRACE,
            execution_id=self._execution_id,
            sequence_number=self._next_sequence(),
            payload={
                "source_node": source_node,
                "target_node": target_node,
                "source_handle": source_handle,
                "target_handle": target_handle,
                "data_preview": self._safe_copy(data)[:100] if isinstance(data, str) else self._safe_copy(data),
            },
        )
    
    def on_condition_evaluated(
        self,
        node_id: str,
        node_type: str,
        node_class: str,
        condition: str,
        input_value: Any,
        result: bool,
        selected_handle: str,
    ) -> DebugEvent:
        """
        Capture a condition evaluation event.
        
        Args:
            node_id: Conditional node ID
            node_type: Type of the node
            node_class: Class name of the node
            condition: The condition expression
            input_value: Value being evaluated
            result: Result of evaluation
            selected_handle: The handle selected based on result
            
        Returns:
            DebugEvent for the condition evaluation
        """
        return DebugEvent(
            event_type=DebugEventType.CONDITION_EVALUATED,
            execution_id=self._execution_id,
            sequence_number=self._next_sequence(),
            node_id=node_id,
            node_type=node_type,
            node_class=node_class,
            payload={
                "condition": condition,
                "input_value": self._safe_copy(input_value),
                "result": result,
                "selected_handle": selected_handle,
            },
        )
    
    def on_llm_generation(
        self,
        node_id: str,
        node_type: str,
        node_class: str,
        model: str,
        prompt_tokens: int,
        completion_tokens: int,
        total_tokens: int,
        response_preview: str,
        duration_ms: float,
    ) -> DebugEvent:
        """
        Capture an LLM generation event.
        
        Args:
            node_id: LLM node ID
            node_type: Type of the node
            node_class: Class name of the node
            model: Model name used
            prompt_tokens: Number of prompt tokens
            completion_tokens: Number of completion tokens
            total_tokens: Total tokens used
            response_preview: Preview of the response
            duration_ms: Generation duration in milliseconds
            
        Returns:
            DebugEvent for the LLM generation
        """
        return DebugEvent(
            event_type=DebugEventType.LLM_GENERATION,
            execution_id=self._execution_id,
            sequence_number=self._next_sequence(),
            node_id=node_id,
            node_type=node_type,
            node_class=node_class,
            payload={
                "model": model,
                "prompt_tokens": prompt_tokens,
                "completion_tokens": completion_tokens,
                "total_tokens": total_tokens,
                "response_preview": response_preview[:200] if len(response_preview) > 200 else response_preview,
                "duration_ms": duration_ms,
            },
        )
    
    def on_iteration_start(
        self,
        loop_node_id: str,
        iteration: int,
        total_items: int,
        current_item: Any,
    ) -> DebugEvent:
        """
        Capture an iteration start event.
        
        Args:
            loop_node_id: Loop node ID
            iteration: Current iteration number (0-based)
            total_items: Total number of items to iterate
            current_item: The current item being processed
            
        Returns:
            DebugEvent for the iteration start
        """
        return DebugEvent(
            event_type=DebugEventType.ITERATION_START,
            execution_id=self._execution_id,
            sequence_number=self._next_sequence(),
            node_id=loop_node_id,
            payload={
                "iteration": iteration,
                "total_items": total_items,
                "current_item_preview": self._safe_copy(current_item),
                "start_time": datetime.now(UTC).isoformat(),
            },
        )
    
    def on_iteration_end(
        self,
        loop_node_id: str,
        iteration: int,
        duration_ms: float,
    ) -> DebugEvent:
        """
        Capture an iteration end event.
        
        Args:
            loop_node_id: Loop node ID
            iteration: Current iteration number (0-based)
            duration_ms: Duration of this iteration in milliseconds
            
        Returns:
            DebugEvent for the iteration end
        """
        return DebugEvent(
            event_type=DebugEventType.ITERATION_END,
            execution_id=self._execution_id,
            sequence_number=self._next_sequence(),
            node_id=loop_node_id,
            payload={
                "iteration": iteration,
                "duration_ms": duration_ms,
                "end_time": datetime.now(UTC).isoformat(),
            },
        )
    
    def on_state_change(
        self,
        node_id: str,
        node_type: str,
        node_class: str,
        old_state: str,
        new_state: str,
    ) -> DebugEvent:
        """
        Capture a state change event.
        
        Args:
            node_id: Node ID
            node_type: Type of the node
            node_class: Class name of the node
            old_state: Previous state
            new_state: New state
            
        Returns:
            DebugEvent for the state change
        """
        return DebugEvent(
            event_type=DebugEventType.STATE_CHANGE,
            severity=DebugEventSeverity.TRACE,
            execution_id=self._execution_id,
            sequence_number=self._next_sequence(),
            node_id=node_id,
            node_type=node_type,
            node_class=node_class,
            payload={
                "old_state": old_state,
                "new_state": new_state,
                "timestamp": datetime.now(UTC).isoformat(),
            },
        )
