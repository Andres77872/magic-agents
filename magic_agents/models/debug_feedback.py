"""
Debug feedback models for tracking node execution information.
"""
from typing import Dict, Any, List, Optional
from pydantic import BaseModel, Field
from datetime import datetime


class NodeDebugInfo(BaseModel):
    """Debug information for a single node execution."""
    
    node_id: str = Field(..., description="Unique identifier for the node")
    node_type: str = Field(..., description="Type of the node (e.g., 'LLM', 'TEXT', 'CONDITIONAL')")
    node_class: str = Field(..., description="Class name of the node")
    
    # Execution timestamps
    start_time: Optional[str] = Field(None, description="ISO timestamp when node execution started")
    end_time: Optional[str] = Field(None, description="ISO timestamp when node execution completed")
    execution_duration_ms: Optional[float] = Field(None, description="Execution duration in milliseconds")
    
    # Input/Output tracking
    inputs: Dict[str, Any] = Field(default_factory=dict, description="Input values received by the node")
    outputs: Dict[str, Any] = Field(default_factory=dict, description="Output values generated by the node")
    
    # Internal state tracking
    internal_variables: Dict[str, Any] = Field(
        default_factory=dict, 
        description="Internal node variables and their values"
    )
    
    # Execution metadata
    was_executed: bool = Field(False, description="Whether the node was actually executed")
    was_bypassed: bool = Field(False, description="Whether the node was bypassed (e.g., conditional path not taken)")
    error: Optional[str] = Field(None, description="Error message if execution failed")
    
    # Additional debug info
    extra_info: Dict[str, Any] = Field(
        default_factory=dict,
        description="Additional debug information specific to node type"
    )


class GraphDebugFeedback(BaseModel):
    """Complete debug feedback for a graph execution."""
    
    execution_id: str = Field(..., description="Unique identifier for this execution")
    graph_type: str = Field(..., description="Type of graph executed")
    
    # Overall execution info
    start_time: str = Field(..., description="ISO timestamp when graph execution started")
    end_time: Optional[str] = Field(None, description="ISO timestamp when graph execution completed")
    total_duration_ms: Optional[float] = Field(None, description="Total execution duration in milliseconds")
    
    # Node-by-node debug info
    nodes: List[NodeDebugInfo] = Field(
        default_factory=list,
        description="Debug information for each node in execution order"
    )
    
    # Execution summary
    total_nodes: int = Field(0, description="Total number of nodes in the graph")
    executed_nodes: int = Field(0, description="Number of nodes actually executed")
    bypassed_nodes: int = Field(0, description="Number of nodes bypassed")
    failed_nodes: int = Field(0, description="Number of nodes that failed")
    
    # Edge information
    edges_processed: List[Dict[str, str]] = Field(
        default_factory=list,
        description="Information about edges processed during execution"
    )
    
    def add_node_info(self, node_info: NodeDebugInfo):
        """Add debug information for a node."""
        self.nodes.append(node_info)
        self.total_nodes += 1
        if node_info.was_executed:
            self.executed_nodes += 1
        if node_info.was_bypassed:
            self.bypassed_nodes += 1
        if node_info.error:
            self.failed_nodes += 1
    
    def add_edge_info(self, source: str, target: str, source_handle: str, target_handle: str):
        """Add information about an edge being processed."""
        self.edges_processed.append({
            "source": source,
            "target": target,
            "source_handle": source_handle,
            "target_handle": target_handle
        })
    
    def finalize(self):
        """Finalize the debug feedback with end time and duration."""
        self.end_time = datetime.utcnow().isoformat()
        if self.start_time and self.end_time:
            start = datetime.fromisoformat(self.start_time)
            end = datetime.fromisoformat(self.end_time)
            self.total_duration_ms = (end - start).total_seconds() * 1000
