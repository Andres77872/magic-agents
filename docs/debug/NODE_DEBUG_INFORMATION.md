# Node Debug Information

This document describes the debug information captured by each node type in the Magic Agents framework.

## Common Information (All Nodes)

All nodes capture these standard fields:

### Standard Fields

| Field | Description |
|-------|-------------|
| `node_id` | Unique identifier for the node instance |
| `node_type` | Type identifier (e.g., "LLM", "TEXT", "CONDITIONAL") |
| `node_class` | Python class name (e.g., "NodeLLM") |
| `start_time` | When node execution started |
| `end_time` | When node execution completed |
| `execution_duration_ms` | How long the node took to execute |
| `inputs` | All input values received from parent nodes |
| `outputs` | All output values sent to child nodes |
| `was_executed` | Whether the node actually executed |
| `was_bypassed` | Whether the node was bypassed (conditional flow) |
| `error` | Error message if execution failed |

### Common Internal Variables

| Variable | Description |
|----------|-------------|
| `_response` | The final response/content produced by the node |
| `cost` | Cost associated with node execution |
| `extra_params` | Additional parameters passed during initialization |

---

## Node-Specific Information

### NodeLLM (LLM)

**Purpose**: Executes LLM generation with streaming or non-streaming mode.

**Internal Variables**:

| Variable | Type | Description |
|----------|------|-------------|
| `stream` | bool | Whether streaming is enabled |
| `json_output` | bool | Whether to parse output as JSON |
| `iterate` | bool | Whether node re-executes in loops |
| `generated` | string | Text generated by the LLM (truncated to 500 chars) |
| `extra_data` | dict | LLM parameters (temperature, top_p, etc.) |

**Input Handles**:
- `handle-client-provider`: The LLM client instance
- `handle-chat`: Chat history object
- `handle-system-context`: System prompt
- `handle_user_message`: User message

**Output Handles**:
- `content`: Streaming chunks (if stream=true)
- `end`: Final generated content

**Example Debug Output**:
```json
{
  "node_id": "llm-node-1",
  "node_type": "LLM",
  "node_class": "NodeLLM",
  "execution_duration_ms": 1250.5,
  "inputs": {
    "handle_user_message": "Explain quantum computing",
    "handle-client-provider": "<MagicLLM>"
  },
  "outputs": {
    "end": {
      "node": "NodeLLM",
      "content": "Quantum computing is..."
    }
  },
  "internal_variables": {
    "stream": true,
    "json_output": false,
    "iterate": false,
    "generated": "Quantum computing is...",
    "extra_data": {
      "temperature": 0.7,
      "top_p": 0.9
    }
  }
}
```

---

### NodeText (TEXT)

**Purpose**: Outputs static text content.

**Internal Variables**:
- Standard variables only

**Input Handles**: None (static content)

**Output Handles**:
- `end`: The static text

**Example Debug Output**:
```json
{
  "node_id": "text-node-1",
  "node_type": "TEXT",
  "node_class": "NodeText",
  "execution_duration_ms": 0.5,
  "inputs": {},
  "outputs": {
    "end": {
      "node": "NodeText",
      "content": "Welcome to the system!"
    }
  },
  "internal_variables": {
    "_response": "Welcome to the system!",
    "text": "Welcome to the system!",
    "text_length": 22,
    "cost": 0.0
  }
}
```

---

### NodeUserInput (USER_INPUT)

**Purpose**: Receives input from the user (start node).

**Internal Variables**:
- `text`: The user's input text
- `images`: List of image URLs/paths (if provided)
- `files`: List of file paths (if provided)

**Input Handles**: None (receives from user)

**Output Handles**:
- `handle_user_message`: The user's input

**Example Debug Output**:
```json
{
  "node_id": "user-input-1",
  "node_type": "USER_INPUT",
  "node_class": "NodeUserInput",
  "execution_duration_ms": 1.2,
  "inputs": {},
  "outputs": {
    "handle_user_message": {
      "node": "NodeUserInput",
      "content": "What is the weather today?"
    }
  },
  "internal_variables": {
    "_response": "What is the weather today?",
    "cost": 0.0,
    "text": "What is the weather today?",
    "images": [],
    "files": []
  }
}
```

---

### NodeConditional (CONDITIONAL)

**Purpose**: Evaluates a condition and routes to appropriate branch.

**Internal Variables**:
- `condition`: The Jinja2 condition template being evaluated
- `merge_strategy`: How multiple inputs are merged ('flat' or 'namespaced')
- `selected_handle`: The handle that was selected after evaluation
- `context_data`: Data available for condition evaluation

**Input Handles**:
- Various (depends on condition requirements)

**Output Handles**:
- Dynamic handles specified in the condition result

**Example Debug Output**:
```json
{
  "node_id": "conditional-1",
  "node_type": "CONDITIONAL",
  "node_class": "NodeConditional",
  "execution_duration_ms": 2.5,
  "inputs": {
    "input_value": 42
  },
  "outputs": {
    "handle_true": {
      "node": "NodeConditional",
      "content": {"input_value": 42}
    }
  },
  "internal_variables": {
    "_response": {"selected": "handle_true", "merge_strategy": "flat", "input_count": 1},
    "condition": "{% if input_value > 10 %}handle_true{% else %}handle_false{% endif %}",
    "merge_strategy": "flat",
    "selected_handle": "handle_true",
    "context_data": {"input_value": 42},
    "cost": 0.0
  }
}
```

---

### NodeLoop (LOOP)

**Purpose**: Iterates over a list of items.

**Internal Variables**:
- `iterate`: Always true for loop nodes
- `input_handle_list`: The configured input handle for the list
- `input_handle_loop`: The configured input handle for loop feedback
- `output_handle_item`: The configured output handle for items
- `output_handle_end`: The configured output handle for end result

**Input Handles**:
- `handle_list`: List of items to iterate (configurable)
- `handle_loop`: Feedback from each iteration (configurable)

**Output Handles**:
- `handle_item`: Current item in iteration (configurable)
- `handle_end`: Aggregated results after all iterations (configurable)

**Example Debug Output**:
```json
{
  "node_id": "loop-1",
  "node_type": "LOOP",
  "node_class": "NodeLoop",
  "execution_duration_ms": 5000.0,
  "inputs": {
    "handle_list": ["item1", "item2", "item3"]
  },
  "outputs": {
    "handle_end": {
      "node": "NodeLoop",
      "content": ["result1", "result2", "result3"]
    }
  },
  "internal_variables": {
    "_response": ["result1", "result2", "result3"],
    "cost": 0.0,
    "iterate": true,
    "input_handle_list": "handle_list",
    "input_handle_loop": "handle_loop",
    "output_handle_item": "handle_item",
    "output_handle_end": "handle_end"
  }
}
```

---

### NodeParser (PARSER)

**Purpose**: Parses and extracts data from input.

**Internal Variables**:
- Parser-specific configuration

**Input Handles**:
- `input`: Content to parse

**Output Handles**:
- `end`: Parsed/extracted data

**Example Debug Output**:
```json
{
  "node_id": "parser-1",
  "node_type": "PARSER",
  "node_class": "NodeParser",
  "execution_duration_ms": 15.0,
  "inputs": {
    "input": "{\"name\": \"John\", \"age\": 30}"
  },
  "outputs": {
    "end": {
      "node": "NodeParser",
      "content": {"name": "John", "age": 30}
    }
  },
  "internal_variables": {
    "_response": {"name": "John", "age": 30},
    "cost": 0.0,
    "template": "Parse the following: {{input}}",
    "template_length": 30
  }
}
```

---

### NodeFetch (FETCH)

**Purpose**: Makes HTTP requests to external APIs.

**Internal Variables**:
- `url`: The URL template being fetched
- `method`: HTTP method (GET, POST, etc.)
- `headers`: Request headers
- `body`: Request body data (if applicable)
- `json_data`: Request JSON body (if applicable)

**Input Handles**:
- Various (depends on configuration, used in URL/body templates)

**Output Handles**:
- `end`: Response data

**Example Debug Output**:
```json
{
  "node_id": "fetch-1",
  "node_type": "FETCH",
  "node_class": "NodeFetch",
  "execution_duration_ms": 250.0,
  "inputs": {
    "url_param": "https://api.example.com/data"
  },
  "outputs": {
    "end": {
      "node": "NodeFetch",
      "content": {"status": "success", "data": [...]}
    }
  },
  "internal_variables": {
    "url": "https://api.example.com/{{url_param}}",
    "method": "GET",
    "headers": {"Authorization": "Bearer ..."},
    "_response": {"status": "success", "data": [...]}
  }
}
```

---

### NodeChat (CHAT)

**Purpose**: Manages conversation history and chat context.

**Internal Variables**:
- `messages_count`: Number of messages in chat history
- `has_system_message`: Whether a system message is set
- `memory`: Memory configuration (stm, ltm, max_input_tokens)

**Input Handles**:
- `handle_user_message`: User message to add to chat

**Output Handles**:
- `handle-chat`: Updated chat object

**Example Debug Output**:
```json
{
  "node_id": "chat-1",
  "node_type": "CHAT",
  "node_class": "NodeChat",
  "execution_duration_ms": 5.0,
  "inputs": {
    "handle_user_message": "Hello!"
  },
  "outputs": {
    "handle-chat": {
      "node": "NodeChat",
      "content": "<ModelChat>"
    }
  },
  "internal_variables": {
    "_response": "<ModelChat>",
    "cost": 0.0,
    "messages_count": 2,
    "has_system_message": true,
    "memory": {"stm": 10, "ltm": 0}
  }
}
```

---

### NodeInner (INNER)

**Purpose**: Executes a nested sub-graph.

**Internal Variables**:
- `has_magic_flow`: Whether the inner graph definition exists
- `has_inner_graph`: Whether the inner graph was built
- `magic_flow`: Summary of inner graph (nodes_count, edges_count, type)
- `inner_graph`: String representation of built graph

**Input Handles**:
- Various (depends on inner graph)

**Output Handles**:
- Various (depends on inner graph)

**Example Debug Output**:
```json
{
  "node_id": "inner-1",
  "node_type": "INNER",
  "node_class": "NodeInner",
  "execution_duration_ms": 1500.0,
  "inputs": {
    "input_data": "Some input"
  },
  "outputs": {
    "end": {
      "node": "NodeInner",
      "content": "Inner graph result"
    }
  },
  "internal_variables": {
    "_response": "Inner graph result",
    "cost": 0.0,
    "has_magic_flow": true,
    "has_inner_graph": true,
    "magic_flow": {"nodes_count": 5, "edges_count": 4, "type": "chat"},
    "inner_graph": "<AgentFlowModel with 5 nodes>"
  }
}
```

---

### NodeEND (END)

**Purpose**: Marks the end of execution flow.

**Internal Variables**:
- `is_terminal_node`: Always true for END nodes

**Input Handles**:
- Various (any final input)

**Output Handles**: None (terminal node)

**Example Debug Output**:
```json
{
  "node_id": "end-1",
  "node_type": "END",
  "node_class": "NodeEND",
  "execution_duration_ms": 0.1,
  "inputs": {
    "final_result": "Execution complete"
  },
  "outputs": {},
  "internal_variables": {
    "_response": null,
    "cost": 0.0,
    "is_terminal_node": true
  }
}
```

---

### NodeClientLLM (CLIENT)

**Purpose**: Provides LLM client configuration.

**Internal Variables**:
- `engine`: The LLM engine being used
- `model`: The model name
- `client_initialized`: Whether the client was successfully initialized
- `init_error`: Any initialization error (if failed)
- `init_error_type`: Type of initialization error (if failed)

**Input Handles**: None (configuration node)

**Output Handles**:
- `end`: The configured MagicLLM client

**Example Debug Output**:
```json
{
  "node_id": "client-1",
  "node_type": "CLIENT",
  "node_class": "NodeClientLLM",
  "execution_duration_ms": 10.0,
  "inputs": {},
  "outputs": {
    "end": {
      "node": "NodeClientLLM",
      "content": "<MagicLLM>"
    }
  },
  "internal_variables": {
    "_response": "<MagicLLM>",
    "cost": 0.0,
    "engine": "openai",
    "model": "gpt-4",
    "client_initialized": true
  }
}
```

---

### NodeSendMessage (SEND_MESSAGE)

**Purpose**: Sends a structured message with extras.

**Internal Variables**:
- `message`: The message content
- `json_extras`: Extra JSON data to include

**Input Handles**:
- `handle_send_extra`: Additional output data

**Output Handles**:
- `content`: ChatCompletionModel with message and extras

**Example Debug Output**:
```json
{
  "node_id": "send-1",
  "node_type": "SEND_MESSAGE",
  "node_class": "NodeSendMessage",
  "execution_duration_ms": 2.0,
  "inputs": {
    "handle_send_extra": {"key": "value"}
  },
  "outputs": {
    "content": {
      "node": "NodeSendMessage",
      "content": "<ChatCompletionModel>"
    }
  },
  "internal_variables": {
    "_response": "<ChatCompletionModel>",
    "cost": 0.0,
    "message": "Response message",
    "json_extras": {"type": "notification"}
  }
}
```

---

## Bypassed Nodes

When a node is bypassed (e.g., in a conditional flow where the branch was not taken):

```json
{
  "node_id": "bypassed-node",
  "node_type": "LLM",
  "node_class": "NodeLLM",
  "start_time": null,
  "end_time": null,
  "execution_duration_ms": null,
  "inputs": {},
  "outputs": {},
  "internal_variables": {},
  "was_executed": false,
  "was_bypassed": true,
  "error": null
}
```

---

## Failed Nodes

When a node fails during execution:

```json
{
  "node_id": "failed-node",
  "node_type": "FETCH",
  "node_class": "NodeFetch",
  "start_time": "2023-10-09T23:20:25.000000",
  "end_time": "2023-10-09T23:20:25.500000",
  "execution_duration_ms": 500.0,
  "inputs": {
    "url": "https://invalid-url"
  },
  "outputs": {},
  "internal_variables": {
    "url": "https://invalid-url",
    "method": "GET"
  },
  "was_executed": true,
  "was_bypassed": false,
  "error": "Connection timeout: failed to connect to server"
}
```

---

## New Debug Event System

The new debug architecture captures node information through typed events. Each node lifecycle emits specific events:

### Node Event Flow

```
NODE_START → (execution) → NODE_END | NODE_ERROR | NODE_BYPASS
```

### Event Types for Nodes

| Event Type | When Emitted | Payload Contains |
|------------|--------------|------------------|
| `NODE_START` | Node execution begins | `node_id`, `node_type`, `inputs` |
| `NODE_END` | Node completes successfully | `node_id`, `node_type`, `outputs`, `internal_state`, `duration_ms` |
| `NODE_ERROR` | Node execution fails | `node_id`, `node_type`, `error`, `inputs`, `partial_outputs` |
| `NODE_BYPASS` | Node skipped (conditional) | `node_id`, `node_type`, `reason` |
| `NODE_RETRY` | Node being retried | `node_id`, `node_type`, `attempt`, `error` |
| `NODE_TIMEOUT` | Node execution timed out | `node_id`, `node_type`, `timeout_ms` |

### DebugEvent Structure for Nodes

```python
from magic_agents.debug import DebugEvent, DebugEventType, DebugEventSeverity
from datetime import datetime

# NODE_START event
start_event = DebugEvent(
    event_id="evt-001",
    event_type=DebugEventType.NODE_START,
    timestamp=datetime.now(),
    execution_id="exec-123",
    node_id="llm-1",
    node_type="LLM",
    severity=DebugEventSeverity.INFO,
    payload={
        "inputs": {
            "handle_user_message": "What is AI?",
            "handle-client-provider": "<MagicLLM>"
        }
    }
)

# NODE_END event
end_event = DebugEvent(
    event_id="evt-002",
    event_type=DebugEventType.NODE_END,
    timestamp=datetime.now(),
    execution_id="exec-123",
    node_id="llm-1",
    node_type="LLM",
    severity=DebugEventSeverity.INFO,
    payload={
        "outputs": {
            "end": {"node": "NodeLLM", "content": "AI stands for..."}
        },
        "internal_state": {
            "stream": True,
            "json_output": False,
            "generated": "AI stands for..."
        }
    },
    duration_ms=1520.0
)

# NODE_ERROR event
error_event = DebugEvent(
    event_id="evt-003",
    event_type=DebugEventType.NODE_ERROR,
    timestamp=datetime.now(),
    execution_id="exec-123",
    node_id="fetch-1",
    node_type="FETCH",
    severity=DebugEventSeverity.ERROR,
    payload={
        "error": "Connection timeout",
        "error_type": "TimeoutError",
        "inputs": {"url": "https://invalid-url"}
    },
    duration_ms=5000.0
)
```

### Using Factory Functions

```python
from magic_agents.debug import (
    node_start_event,
    node_end_event,
    node_error_event,
    node_bypass_event
)

# Create events using factory functions
start = node_start_event(
    execution_id="exec-123",
    node_id="llm-1",
    node_type="LLM",
    inputs={"prompt": "Hello"}
)

end = node_end_event(
    execution_id="exec-123",
    node_id="llm-1",
    node_type="LLM",
    outputs={"response": "Hi there!"},
    internal_state={"tokens": 15},
    duration_ms=150.0
)

error = node_error_event(
    execution_id="exec-123",
    node_id="fetch-1",
    node_type="FETCH",
    error="Connection failed",
    inputs={"url": "https://example.com"}
)

bypass = node_bypass_event(
    execution_id="exec-123",
    node_id="conditional-branch",
    node_type="LLM",
    reason="Branch not taken"
)
```

### Converting Events to Legacy NodeDebugInfo

```python
from magic_agents.debug import DebugCollector

collector = DebugCollector(execution_id="exec-123")
collector.add_event(start)
collector.add_event(end)

# Get summary with legacy format
summary = collector.get_summary()
legacy = summary.to_legacy_format()

# legacy["nodes"] contains NodeDebugInfo-compatible dicts
for node in legacy["nodes"]:
    print(f"{node['node_id']}: {node['execution_duration_ms']}ms")
```

---

## See Also

- [Debug Mode Overview](./DEBUG_MODE_OVERVIEW.md)
- [Debug Feedback Structure](./DEBUG_FEEDBACK_STRUCTURE.md)
- [Debug Mode Examples](./DEBUG_MODE_EXAMPLES.md)
