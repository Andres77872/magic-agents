# Debug Feedback Structure

## GraphDebugFeedback

The top-level debug feedback object contains comprehensive information about the entire graph execution.

### Fields

| Field | Type | Description |
|-------|------|-------------|
| `execution_id` | string | Unique identifier for this execution |
| `graph_type` | string | Type of graph executed (e.g., "chat") |
| `start_time` | string | ISO timestamp when execution started |
| `end_time` | string | ISO timestamp when execution completed |
| `total_duration_ms` | float | Total execution duration in milliseconds |
| `nodes` | List[NodeDebugInfo] | Debug information for each node |
| `edges_processed` | List[dict] | Information about edges processed |
| `total_nodes` | int | Total number of nodes in the graph |
| `executed_nodes` | int | Number of nodes actually executed |
| `bypassed_nodes` | int | Number of nodes bypassed |
| `failed_nodes` | int | Number of nodes that failed |

### Example

```json
{
  "execution_id": "a1b2c3d4e5f6",
  "graph_type": "chat",
  "start_time": "2023-10-09T23:20:25.123456",
  "end_time": "2023-10-09T23:20:27.456789",
  "total_duration_ms": 2333.333,
  "total_nodes": 5,
  "executed_nodes": 4,
  "bypassed_nodes": 1,
  "failed_nodes": 0,
  "nodes": [...],
  "edges_processed": [...]
}
```

---

## NodeDebugInfo

Debug information for a single node execution.

### Fields

| Field | Type | Description |
|-------|------|-------------|
| `node_id` | string | Unique identifier for the node |
| `node_type` | string | Type identifier (e.g., "LLM", "TEXT") |
| `node_class` | string | Class name (e.g., "NodeLLM", "NodeText") |
| `start_time` | string (optional) | ISO timestamp when node execution started |
| `end_time` | string (optional) | ISO timestamp when node execution completed |
| `execution_duration_ms` | float (optional) | Execution duration in milliseconds |
| `inputs` | dict | Input values received by the node |
| `outputs` | dict | Output values generated by the node |
| `internal_variables` | dict | Internal node state and variables |
| `was_executed` | bool | Whether the node was actually executed |
| `was_bypassed` | bool | Whether the node was bypassed |
| `error` | string (optional) | Error message if execution failed |
| `extra_info` | dict | Additional node-specific debug info |

### Example

```json
{
  "node_id": "node-1",
  "node_type": "LLM",
  "node_class": "NodeLLM",
  "start_time": "2023-10-09T23:20:25.200000",
  "end_time": "2023-10-09T23:20:26.500000",
  "execution_duration_ms": 1300.0,
  "inputs": {
    "handle_user_message": "What is the weather?",
    "handle-client-provider": "<MagicLLM>"
  },
  "outputs": {
    "end": {
      "node": "NodeLLM",
      "content": "I don't have access to real-time weather data..."
    }
  },
  "internal_variables": {
    "_response": "I don't have access to real-time weather data...",
    "cost": 0.0,
    "stream": true,
    "json_output": false,
    "iterate": false,
    "generated": "I don't have access to real-time weather data...",
    "extra_data": {
      "temperature": 0.7
    }
  },
  "was_executed": true,
  "was_bypassed": false,
  "error": null
}
```

---

## Edge Information

Information about edges processed during execution.

### Structure

```json
{
  "source": "node-1",
  "target": "node-2",
  "source_handle": "end",
  "target_handle": "input"
}
```

### Fields

| Field | Type | Description |
|-------|------|-------------|
| `source` | string | ID of the source node |
| `target` | string | ID of the target node |
| `source_handle` | string | Output handle from source node |
| `target_handle` | string | Input handle on target node |

---

## Data Types

### Inputs Dictionary

The `inputs` dictionary contains all input values the node received, keyed by their target handle names:

```json
{
  "handle_user_message": "User's input text",
  "handle-system-context": "System prompt",
  "handle-client-provider": "<MagicLLM>"
}
```

### Outputs Dictionary

The `outputs` dictionary contains all output values the node generated, keyed by their source handle names:

```json
{
  "end": {
    "node": "NodeLLM",
    "content": "Generated response text"
  },
  "handle_success": {
    "node": "NodeConditional",
    "content": true
  }
}
```

### Internal Variables Dictionary

The `internal_variables` dictionary contains node-specific internal state. The contents vary by node type:

**Common Variables** (all nodes):
- `_response`: The final response/output of the node
- `cost`: Cost associated with the node execution
- `extra_params`: Extra parameters passed to the node

**NodeLLM Specific**:
- `stream`: Whether streaming is enabled
- `json_output`: Whether JSON parsing is enabled
- `iterate`: Whether the node re-executes in loops
- `generated`: The text generated by the LLM
- `extra_data`: Extra data passed to the LLM (temperature, top_p, etc.)

See [Node Debug Information](./NODE_DEBUG_INFORMATION.md) for complete details on each node type.

---

## Serialization

All values in the debug feedback are serialized to be JSON-compatible:

- **Basic types** (string, int, float, bool, None): Passed through as-is
- **Dictionaries and lists**: Recursively serialized
- **Complex objects**: Converted to string representation `<ClassName>`
- **Long strings**: May be truncated (e.g., generated text limited to 500 chars)

This ensures the debug feedback can be safely transmitted and stored.

---

## DebugEvent (New Architecture)

The new debug system uses a unified `DebugEvent` structure for all debug events. This provides more granular control and supports streaming.

### DebugEvent Fields

| Field | Type | Description |
|-------|------|-------------|
| `event_id` | string | Unique identifier for this event (UUID) |
| `event_type` | DebugEventType | Type of event (NODE_START, NODE_END, etc.) |
| `timestamp` | datetime | When the event occurred |
| `execution_id` | string | Links events to same graph execution |
| `node_id` | string (optional) | Node this event relates to |
| `node_type` | string (optional) | Type of node (LLM, TEXT, etc.) |
| `severity` | DebugEventSeverity | DEBUG, INFO, WARNING, ERROR, CRITICAL |
| `payload` | dict | Event-specific data |
| `metadata` | dict (optional) | Additional context |
| `parent_event_id` | string (optional) | For nested events |
| `correlation_id` | string (optional) | Groups related events |
| `duration_ms` | float (optional) | Duration for end events |

### Example DebugEvent

```python
from magic_agents.debug import DebugEvent, DebugEventType, DebugEventSeverity

event = DebugEvent(
    event_id="evt-123",
    event_type=DebugEventType.NODE_END,
    timestamp=datetime.now(),
    execution_id="exec-456",
    node_id="llm-node-1",
    node_type="LLM",
    severity=DebugEventSeverity.INFO,
    payload={
        "inputs": {"handle_prompt": "Hello"},
        "outputs": {"end": {"content": "Hi there!"}},
        "internal_state": {"tokens": 15}
    },
    duration_ms=1234.5
)
```

### Converting to Legacy Format

For backward compatibility, DebugEvent can be converted to the legacy format:

```python
# Convert single event
legacy_dict = event.to_legacy_format()

# Or use collector for full summary
from magic_agents.debug import DebugCollector

collector = DebugCollector(execution_id="exec-456")
collector.add_event(event)
summary = collector.get_summary()
legacy = summary.to_legacy_format()  # GraphDebugFeedback compatible
```

---

## Event Severity Levels

| Severity | Use Case |
|----------|----------|
| `DEBUG` | Detailed internal info (verbose mode only) |
| `INFO` | Normal execution events |
| `WARNING` | Unusual but non-fatal conditions |
| `ERROR` | Node/operation failures |
| `CRITICAL` | Graph-level failures |

---

## Streaming vs Summary

The debug system supports two output modes:

### Streaming Mode
Events are emitted in real-time as they occur:
```python
async with debug_context(config) as ctx:
    async for event in ctx.events():
        print(f"[{event.event_type}] {event.node_id}")
```

### Summary Mode  
Events are collected and aggregated into a summary:
```python
collector = DebugCollector(execution_id="exec-123")
# ... events added during execution ...
summary = collector.get_summary()  # GraphExecutionSummary
```

