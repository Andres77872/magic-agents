# Debug Mode Overview

## Introduction

The Magic Agents framework includes a comprehensive debug mode that provides detailed feedback about graph execution. When debug mode is enabled, the system captures and returns information about:

- **Node Inputs**: All input values received by each node
- **Node Outputs**: All output values generated by each node  
- **Internal Variables**: Node-specific internal state and variables
- **Execution Timing**: Start time, end time, and duration for each node
- **Execution Flow**: Information about which nodes were executed, bypassed, or failed
- **Edge Processing**: Details about data flow between nodes

## Debug System Architecture

The debug system is built on a modular **Capture-Transform-Emit** architecture:

```
┌─────────────────────────────────────────────────────────────────────┐
│                     Debug Event Abstraction Layer                   │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  ┌──────────────┐    ┌─────────────────┐    ┌───────────────────┐  │
│  │   CAPTURE    │───▶│   TRANSFORM     │───▶│      EMIT         │  │
│  │   (Hooks)    │    │   (Pipeline)    │    │   (Dispatcher)    │  │
│  └──────────────┘    └─────────────────┘    └───────────────────┘  │
│         │                    │                       │              │
│         ▼                    ▼                       ▼              │
│  ┌──────────────┐    ┌─────────────────┐    ┌───────────────────┐  │
│  │ NodeCapture  │    │ RedactPipeline  │    │ QueueEmitter      │  │
│  │ EdgeCapture  │    │ FilterPipeline  │    │ LogEmitter        │  │
│  │ StateCapture │    │ TruncatePipeline│    │ CallbackEmitter   │  │
│  └──────────────┘    └─────────────────┘    └───────────────────┘  │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### Key Components

| Component | File | Purpose |
|-----------|------|---------|
| `DebugEvent` | `events.py` | Unified event structure for all debug events |
| `DefaultDebugCapture` | `capture.py` | Captures lifecycle events into DebugEvents |
| `TransformPipeline` | `transform.py` | Chains transformers to filter/redact/truncate |
| `QueueEmitter` | `emitter.py` | Emits events to async queues for streaming |
| `DebugCollector` | `collector.py` | Aggregates events into summaries |
| `DebugContext` | `context.py` | Manages debug lifecycle during execution |
| `DebugConfig` | `config.py` | Configuration presets (default, minimal, verbose) |

## Enabling Debug Mode

Debug mode is controlled by a flag in the graph JSON definition:

```json
{
  "type": "chat",
  "debug": true,
  "nodes": [...],
  "edges": [...]
}
```

When `debug: true` is set, all nodes in the graph will automatically track their execution state.

## Debug Output Structure

When debug mode is enabled, the execution will yield debug messages in two forms:

### 1. Per-Node Debug Messages

After each node execution (or error), the system yields an immediate debug message with type `"debug"` containing information about that specific node:

```python
{
  "type": "debug",
  "content": {
    "node_id": "node-1",
    "node_type": "LLM",
    "node_class": "NodeLLM",
    "start_time": "2023-10-09T23:20:25.200000",
    "end_time": "2023-10-09T23:20:26.500000",
    "execution_duration_ms": 1300.0,
    "inputs": {...},
    "outputs": {...},
    "internal_variables": {...},
    "was_executed": true,
    "was_bypassed": false,
    "error": null
  }
}
```

**Key Features:**
- Yielded **immediately** after each node completes execution
- Yielded **on error** before the exception is propagated
- Allows real-time monitoring of graph execution progress
- Enables immediate debugging of node-specific issues

### 2. Final Summary Debug Message

At the end of graph execution, the system yields a comprehensive summary with type `"debug_summary"`:

```python
{
  "type": "debug_summary",
  "content": {
    "execution_id": "unique-execution-id",
    "graph_type": "chat",
    "start_time": "2023-10-09T23:20:25.123456",
    "end_time": "2023-10-09T23:20:27.456789",
    "total_duration_ms": 2333.333,
    "nodes": [...],
    "edges_processed": [...],
    "total_nodes": 5,
    "executed_nodes": 4,
    "bypassed_nodes": 1,
    "failed_nodes": 0
  }
}
```

**Summary Includes:**
- Complete list of all executed and bypassed nodes
- All edges processed during execution
- Aggregate statistics (total nodes, executed, bypassed, failed)
- Overall execution timing and duration

## Use Cases

### Development & Testing
- Verify node inputs and outputs during development
- Debug complex conditional flows
- Understand execution order and timing
- Identify performance bottlenecks

### Troubleshooting
- Diagnose why a node didn't execute as expected
- Understand which conditional branches were taken
- Inspect internal state when debugging issues
- Track data transformations through the graph

### Monitoring & Logging
- Collect detailed execution logs for analysis
- Monitor graph performance in production
- Audit data flow through sensitive operations
- Generate execution reports

## Execution Flow with Debug Mode

When debug mode is enabled, the execution flow is:

1. **Node Starts Execution**: Debug tracking begins, capturing start time and inputs
2. **Node Processes**: Normal node processing occurs
3. **Node Completes or Errors**: 
   - Debug tracking ends, capturing outputs and internal state
   - **Debug message is yielded immediately** (type: `"debug"`)
4. **Next Node Executes**: Repeat steps 1-3
5. **Graph Completes**: Final summary is yielded (type: `"debug_summary"`)

This immediate yielding approach allows for:
- **Real-time monitoring**: See node execution as it happens
- **Early error detection**: Get debug info immediately when a node fails
- **Progressive debugging**: Debug one node at a time without waiting for full graph completion

## Performance Considerations

Debug mode adds overhead to graph execution:

- **Memory**: Stores copies of all inputs, outputs, and internal state
- **CPU**: Additional processing for state capture and serialization
- **Response Size**: Debug feedback can be large for complex graphs (multiple messages per execution)
- **Network**: Immediate yielding increases number of messages transmitted

**Recommendation**: Only enable debug mode during development, testing, or when actively troubleshooting issues. Disable it in production for optimal performance.

## Debug Event Types (New Architecture)

The new debug system uses typed events for fine-grained control:

### Graph Events
| Event Type | Description |
|------------|-------------|
| `GRAPH_START` | Graph execution begins |
| `GRAPH_END` | Graph execution completes |
| `GRAPH_ERROR` | Graph-level error occurred |

### Node Events
| Event Type | Description |
|------------|-------------|
| `NODE_START` | Node begins execution |
| `NODE_END` | Node completes successfully |
| `NODE_ERROR` | Node execution failed |
| `NODE_BYPASS` | Node was skipped (conditional) |
| `NODE_RETRY` | Node is being retried |
| `NODE_TIMEOUT` | Node execution timed out |

### Edge Events  
| Event Type | Description |
|------------|-------------|
| `EDGE_TRANSFER_START` | Data transfer begins |
| `EDGE_TRANSFER_END` | Data transfer completes |

### LLM Events
| Event Type | Description |
|------------|-------------|
| `LLM_REQUEST_START` | LLM API request begins |
| `LLM_REQUEST_END` | LLM API response received |
| `LLM_TOKEN_GENERATED` | Token streaming event |
| `LLM_ERROR` | LLM API error |

### Loop Events
| Event Type | Description |
|------------|-------------|
| `LOOP_ITERATION_START` | Loop iteration begins |
| `LOOP_ITERATION_END` | Loop iteration completes |
| `LOOP_BREAK` | Loop break condition met |
| `LOOP_CONTINUE` | Loop continue triggered |

### Conditional Events
| Event Type | Description |
|------------|-------------|
| `CONDITIONAL_EVALUATION` | Condition being evaluated |
| `CONDITIONAL_BRANCH_TAKEN` | Branch selection made |

## Configuration Presets

The debug system provides built-in configuration presets:

```python
from magic_agents.debug import DebugConfig

# Full debug information (development)
config = DebugConfig.default()

# Minimal overhead (staging)
config = DebugConfig.minimal()

# Complete event capture (troubleshooting)
config = DebugConfig.verbose()

# Errors only (production)
config = DebugConfig.errors_only()

# Custom configuration
config = DebugConfig(
    enabled=True,
    capture_inputs=True,
    capture_outputs=True,
    capture_internal_state=False,  # Skip internal vars
    max_string_length=500,
    redact_patterns=["password", "api_key", "token"]
)
```

## See Also

- [Debug Feedback Structure](./DEBUG_FEEDBACK_STRUCTURE.md) - Detailed structure of debug output
- [Node Debug Information](./NODE_DEBUG_INFORMATION.md) - What information each node captures
- [Debug Mode Examples](./DEBUG_MODE_EXAMPLES.md) - Example usage patterns
