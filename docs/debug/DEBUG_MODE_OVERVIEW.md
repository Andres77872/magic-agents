# Debug Mode Overview

## Introduction

The Magic Agents framework includes a comprehensive debug mode that provides detailed feedback about graph execution. When debug mode is enabled, the system captures and returns information about:

- **Node Inputs**: All input values received by each node
- **Node Outputs**: All output values generated by each node  
- **Internal Variables**: Node-specific internal state and variables
- **Execution Timing**: Start time, end time, and duration for each node
- **Execution Flow**: Information about which nodes were executed, bypassed, or failed
- **Edge Processing**: Details about data flow between nodes

## Enabling Debug Mode

Debug mode is controlled by a flag in the graph JSON definition:

```json
{
  "type": "chat",
  "debug": true,
  "nodes": [...],
  "edges": [...]
}
```

When `debug: true` is set, all nodes in the graph will automatically track their execution state.

## Debug Output Structure

When debug mode is enabled, the execution will yield debug messages in two forms:

### 1. Per-Node Debug Messages

After each node execution (or error), the system yields an immediate debug message with type `"debug"` containing information about that specific node:

```python
{
  "type": "debug",
  "content": {
    "node_id": "node-1",
    "node_type": "LLM",
    "node_class": "NodeLLM",
    "start_time": "2023-10-09T23:20:25.200000",
    "end_time": "2023-10-09T23:20:26.500000",
    "execution_duration_ms": 1300.0,
    "inputs": {...},
    "outputs": {...},
    "internal_variables": {...},
    "was_executed": true,
    "was_bypassed": false,
    "error": null
  }
}
```

**Key Features:**
- Yielded **immediately** after each node completes execution
- Yielded **on error** before the exception is propagated
- Allows real-time monitoring of graph execution progress
- Enables immediate debugging of node-specific issues

### 2. Final Summary Debug Message

At the end of graph execution, the system yields a comprehensive summary with type `"debug_summary"`:

```python
{
  "type": "debug_summary",
  "content": {
    "execution_id": "unique-execution-id",
    "graph_type": "chat",
    "start_time": "2023-10-09T23:20:25.123456",
    "end_time": "2023-10-09T23:20:27.456789",
    "total_duration_ms": 2333.333,
    "nodes": [...],
    "edges_processed": [...],
    "total_nodes": 5,
    "executed_nodes": 4,
    "bypassed_nodes": 1,
    "failed_nodes": 0
  }
}
```

**Summary Includes:**
- Complete list of all executed and bypassed nodes
- All edges processed during execution
- Aggregate statistics (total nodes, executed, bypassed, failed)
- Overall execution timing and duration

## Use Cases

### Development & Testing
- Verify node inputs and outputs during development
- Debug complex conditional flows
- Understand execution order and timing
- Identify performance bottlenecks

### Troubleshooting
- Diagnose why a node didn't execute as expected
- Understand which conditional branches were taken
- Inspect internal state when debugging issues
- Track data transformations through the graph

### Monitoring & Logging
- Collect detailed execution logs for analysis
- Monitor graph performance in production
- Audit data flow through sensitive operations
- Generate execution reports

## Execution Flow with Debug Mode

When debug mode is enabled, the execution flow is:

1. **Node Starts Execution**: Debug tracking begins, capturing start time and inputs
2. **Node Processes**: Normal node processing occurs
3. **Node Completes or Errors**: 
   - Debug tracking ends, capturing outputs and internal state
   - **Debug message is yielded immediately** (type: `"debug"`)
4. **Next Node Executes**: Repeat steps 1-3
5. **Graph Completes**: Final summary is yielded (type: `"debug_summary"`)

This immediate yielding approach allows for:
- **Real-time monitoring**: See node execution as it happens
- **Early error detection**: Get debug info immediately when a node fails
- **Progressive debugging**: Debug one node at a time without waiting for full graph completion

## Performance Considerations

Debug mode adds overhead to graph execution:

- **Memory**: Stores copies of all inputs, outputs, and internal state
- **CPU**: Additional processing for state capture and serialization
- **Response Size**: Debug feedback can be large for complex graphs (multiple messages per execution)
- **Network**: Immediate yielding increases number of messages transmitted

**Recommendation**: Only enable debug mode during development, testing, or when actively troubleshooting issues. Disable it in production for optimal performance.

## See Also

- [Debug Feedback Structure](./DEBUG_FEEDBACK_STRUCTURE.md) - Detailed structure of debug output
- [Node Debug Information](./NODE_DEBUG_INFORMATION.md) - What information each node captures
- [Debug Mode Examples](./DEBUG_MODE_EXAMPLES.md) - Example usage patterns
